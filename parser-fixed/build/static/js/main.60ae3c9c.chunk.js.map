{"version":3,"sources":["FancyTextarea.tsx","OutputRow.tsx","OutputList.tsx","Display.tsx","nfa.ts","regex.ts","Intro.tsx","GUIComp.tsx","App.tsx","index.tsx"],"names":["FancyTextarea","e","contents","target","value","this","props","onchange","className","maxLength","placeholder","onChange","React","Component","OutputRow","pattStr","testStr","success","OutputList","state","propsList","addToList","bind","setAddToList","unshift","setState","map","Display","outputList","id","Array","prototype","unique","Set","deepReverse","reverse","el","isArray","Object","complexmap","f","obj","i","entries","key","hasOwnProperty","Alphabet","chars","charList","EPSILON_CHAR","split","filter","char","OPS","has","console","log","join","string","length","Error","indexOf","other","getCharList","l","next","done","fromEntries","a","b","Symbol","iterator","EMPTY","NFA","sigma","delta","start","accept","size","current","to","flat","follow","nextStates","inputChars","currentStates","shift","undefined","some","str","d","shiftSize","transitionRow","states","transitionChar","reindexDelta","union","deltaRowTemplate","getRowTemplate","bDelta","aDelta","prepareOperations","bAcceptShifted","joiningStateRow","transitionRowPartial","assign","forEach","index","push","startStateIndex","bStartShifted","empty","endingStateRow","EPSILON","concatenate","star","precd","astv","arity","infixToPostfix","op","outQueue","opStack","getStackTop","shouldReduceOp","top","opStr1","opStr2","order","String","localeCompare","call","expressionEndMetArr","depth","escapehatch","pop","treeToNFA","tree","CHAR","els","maybe","convertRegexToNFAFunction","fixed","arr","stack","isOp","keys","newTr","splice","end","postfixToTree","nfa","fixEpsilonClosure","eval","s","Intro","GUI","evalFunction","test","on_patt_change","on_test_change","updateSuccessValue","keyCode","preventDefault","onKeyDown","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.60ae3c9c.chunk.js","sourcesContent":["//  Author justin lee\r\nimport React from 'react';\r\n\r\ninterface TextareaProps {\r\n    placeholder: string;\r\n    onchange: (str: string) => void;\r\n}\r\n\r\ninterface TextareaState { }\r\n\r\nclass FancyTextarea extends React.Component<TextareaProps, TextareaState> {\r\n\r\n    onchange (e: any) {\r\n        const contents = e.target.value;\r\n        \r\n        this.props.onchange(contents);\r\n    }\r\n\r\n    render () {\r\n        return (\r\n            <div className = \"textarea_outer\">\r\n                <textarea  maxLength={30} data-gramm=\"false\" placeholder={this.props.placeholder}  onChange={(e) => this.onchange(e)}></textarea>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\nexport default FancyTextarea;","//author justin lee\r\nimport React from 'react';\r\n\r\ninterface OutputRowProps {\r\n    pattStr: string;\r\n    testStr: string;\r\n    success: boolean;\r\n}\r\n\r\ninterface OutputRowState { }\r\nclass OutputRow extends React.Component<OutputRowProps, OutputRowState> {\r\n    render() {\r\n        const {pattStr, testStr} = this.props;\r\n        return (\r\n            <tr className=\"output_row\">\r\n                <td>{pattStr ? `/${pattStr}/` : \"(empty)\"}</td>\r\n                <td>{testStr ? `\"${testStr}\"` : \"(empty)\"}</td>\r\n                <td className={\"success_\"+this.props.success}>{this.props.success ? \"Accept\" : \"Reject\"}</td>\r\n            </tr>\r\n        )\r\n    }\r\n}\r\n\r\nexport default OutputRow;\r\n\r\nexport type {\r\n    OutputRowProps\r\n}","//  Author justin lee\r\nimport React from 'react';\r\nimport OutputRow, {OutputRowProps} from './OutputRow';\r\n\r\ninterface OutputListProps {    \r\n    setAddToList: (f: (props: OutputRowProps) => void) => void;\r\n}\r\n\r\ninterface OutputListState {\r\n    propsList: OutputRowProps[];\r\n}\r\n\r\nclass OutputList extends React.Component<OutputListProps, OutputListState> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {\r\n            propsList: [],\r\n        }\r\n        this.addToList = this.addToList.bind(this);\r\n        this.props.setAddToList(this.addToList);\r\n    }\r\n    \r\n    addToList(props: OutputRowProps) {\r\n        \r\n        const propsList = this.state.propsList;\r\n        propsList.unshift(props);\r\n        this.setState({ propsList });\r\n    }\r\n\r\n    render() {\r\n        return this.state.propsList.map(({pattStr, testStr, success}) => \r\n        <OutputRow pattStr={pattStr} testStr={testStr} success={success} />\r\n        )\r\n    }    \r\n}\r\n\r\nexport default OutputList","//  Author justin lee\r\n\r\nimport React from 'react';\r\nimport OutputRow, {OutputRowProps} from './OutputRow';\r\nimport OutputList from './OutputList';\r\n\r\ninterface DisplayProps {\r\n    pattStr: string;\r\n    testStr: string;\r\n    success: boolean;\r\n    setAddToList: (f: (props: OutputRowProps) => void) => void;\r\n\r\n}\r\n\r\ninterface DisplayState {\r\n    outputList: OutputRowProps[];\r\n    addToList: (props: OutputRowProps) => void; \r\n}\r\n\r\nclass Display extends React.Component<DisplayProps, DisplayState> {\r\n    constructor(props: DisplayProps) {\r\n        super(props);\r\n        const {pattStr, testStr, success} = props;\r\n        this.state = {\r\n            outputList: [{\r\n                pattStr, testStr, success,\r\n            }],\r\n            addToList: (props: OutputRowProps) => 0,\r\n        }\r\n    }\r\n    \r\n    \r\n    addToList (props: OutputRowProps) {\r\n        return this.state.addToList(props);\r\n    }\r\n    \r\n    render() {\r\n\r\n        const {pattStr, testStr, success} = this.props;\r\n\r\n        return (\r\n            <table id=\"displayTable\">\r\n            <OutputRow pattStr={pattStr} testStr={testStr} success={success} />\r\n            <OutputList setAddToList={(addToList: (props: OutputRowProps) => void) => {\r\n                this.setState({addToList});\r\n                this.props.setAddToList(addToList);\r\n            }}/> \r\n            </table>\r\n        )\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default Display;","// Author justin lee oct nov 2021\r\n// recommented nov 2021 to add more expanation\r\n\r\ndeclare global { // stops typescript throwing errors\r\n    interface Array<T> {\r\n        deepReverse(): Array<T>;\r\n        unique(): Array<T>;\r\n    }\r\n\r\n    interface Object {\r\n        complexmap<T, Q>(f: (value: T, key?: string | number | symbol, index?: number) => Q) : Record<any, any>;\r\n    }\r\n}\r\n\r\nArray.prototype.unique = function() : Array<any> { // removes all dupe elements from array.\r\n    return [ ...new Set(this)];\r\n    // only works for primitives\r\n}\r\nArray.prototype.deepReverse = function() {\r\n    return this.reverse().map(function(el: any) { // deep reverse (all non-array elements)\r\n        if (Array.isArray(el)) return el.deepReverse();\r\n        return el;\r\n    })\r\n}\r\n// map based on a given structure\r\nObject.prototype.complexmap = function<T, Q>( f: (value: T, key?: string | number | symbol, index?: number) => Q) : Record<any, Q> {\r\n// I kept modifying the structure of the delta tables cause i was indecisive and it was confusing to have to keep changing map. so i made a general map\r\n    let obj: Record<any, Q> = {}; let i = 0;\r\n    \r\n    for (let [key, value] of Object.entries(this)) {\r\n        if (!this.hasOwnProperty(key)) continue;\r\n        obj[key] = f(value as T, key, i++);\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\ntype DeltaRow = Record<string, number[]>\r\ntype Delta = DeltaRow[]; // an array of objects whos keys are strings (chars) and whos values are arrays of numbers (integers);\r\n\r\ntype StructString = string | StructString[];\r\n\r\n\r\n    // define an alphabet class to use for Sigma\r\n    // essentially a set with a lot of added funcitonality\r\n    \r\nclass Alphabet {\r\n\r\n    private charList: string[] = [];\r\n    \r\n    static readonly OPS = new Set('*()|~'.split(''));\r\n\r\n    static readonly EPSILON_CHAR = '%';\r\n    \r\n    // \"preset\" alphabets. build function never declares new - just combines using \"presets\",\r\n    // being 'char', 'epsilon' and then modifying them and adding states\r\n    static readonly EMPTY = new Alphabet(\"\");\r\n\r\n    constructor(chars: string) {\r\n        // Get all the unique characters that aren't operators\r\n        this.charList = (chars + Alphabet.EPSILON_CHAR)\r\n            .split('')\r\n            .filter(char => ! Alphabet.OPS.has(char))\r\n            .unique();           \r\n    }\r\n    \r\n    debug () : void {\r\n    \tconsole.log(`Alphabet: '` + this.charList.join(`', '`) + `'`);\r\n    }\r\n\r\n    getCharList() : string {\r\n        return this.charList.join(''); \r\n    }\r\n\r\n    //check char presence in Alphabet.\r\n    has (string: string) : boolean {\r\n        if (string.length !== 1) throw new Error(\"chars can only be of length 1\");\r\n        return this.charList.indexOf(string) >= 0;\r\n    }\r\n\r\n    equals (other: Alphabet) : boolean {\r\n        return this.getCharList() === other.getCharList();\r\n    }\r\n\r\n    static union(a: Alphabet, b: Alphabet) : Alphabet { \r\n        return new Alphabet(a.getCharList() + b.getCharList());\r\n    }\r\n    \r\n    // so I can loop through the alphabet using for... of\r\n    [Symbol.iterator]() {\r\n        let i = 0, l = this.charList.length;\r\n        return ({\r\n            next: () => ({\r\n                done: l === i + 1,\r\n                value: this.charList[i++],\r\n            })\r\n        });\r\n    }\r\n  \r\n    // creates a \"template\" version of self with instance data removed\r\n    // to use with object.assign\r\n    getRowTemplate() : DeltaRow {\r\n        return Object.fromEntries(this.charList.map(char => [char, []]));\r\n    }\r\n}\r\n\r\nclass NFA {\r\n    \r\n    constructor(protected readonly sigma: Alphabet, protected readonly delta: Delta, protected readonly start: number, protected readonly accept: number[]) {\r\n        this.size = this.delta.length;\r\n    }\r\n\r\n    readonly size: number; \r\n\r\n    // a single accept state\r\n    static readonly EPSILON: (() => NFA) = () => new NFA(Alphabet.EMPTY, [{[Alphabet.EPSILON_CHAR]: []}], 0, [0]);\r\n\r\n    //no states or anything. identity value for combination functions\r\n    static readonly EMPTY: (() => NFA) = () => new NFA(Alphabet.EMPTY, [], -12345678, []);\r\n\r\n    // nfa that matches a single character.\r\n    static CHAR(str: string) : NFA {\r\n        return new NFA(new Alphabet(str), [{[str]: [1], [Alphabet.EPSILON_CHAR]: []}, {[str]: [], [Alphabet.EPSILON_CHAR]: []}], 0, [1]);\r\n    }\r\n\r\n    // all states have an index. to use a binary operator, we need to reindex \r\n    // one of the child NFAs so there is no overlap in indices\r\n    static reindexDelta(d: Delta, shiftSize: number) : Delta {\r\n        return d.map((transitionRow: DeltaRow) => transitionRow\r\n                .complexmap<number[], number[]>((states: number[], transitionChar) => states \r\n                    .map((state: number) => state + shiftSize)));\r\n    }\r\n\r\n    static copyDelta(d: Delta) : Delta {\r\n        return NFA.reindexDelta(d, 0);\r\n    }\r\n\r\n    \r\n    static prepareOperations(a: NFA, b: NFA) {\r\n        // Create a new alphabet, with the characters of both.\r\n        const sigma = Alphabet.union(a.sigma, b.sigma);\r\n        // Create an object to build off of, that looks like a row (state) of transitions.\r\n        const deltaRowTemplate = sigma.getRowTemplate();\r\n\r\n        // We're making an array to add them together, so we've got to shift the indices of the second set of \r\n        // states over\r\n        const shiftSize = a.size;\r\n        const bDelta = NFA.reindexDelta(b.delta, shiftSize);\r\n\r\n        const aDelta = NFA.reindexDelta(a.delta, 0);\r\n\r\n            // Mapping on each \"from\" state, then on each character, then on each \"to\" state, to adjust\r\n            // state values by the shiftSize\r\n           \r\n        return {\r\n            sigma,\r\n            deltaRowTemplate,\r\n            shiftSize,\r\n            aDelta,\r\n            bDelta,\r\n           // bStartShifted\r\n        }\r\n    }\r\n\r\n    // |\r\n    static union(a: NFA, b: NFA) : NFA {\r\n        \r\n        // get the alphabet, row template, b shift value, origional a delta, and shifted b delta\r\n        const {sigma, deltaRowTemplate, shiftSize, aDelta, bDelta} = NFA.prepareOperations(a, b);\r\n\r\n        // reindex accept states as well\r\n        const bAcceptShifted = b.accept.map((state: number) => state + shiftSize);\r\n\r\n        // We create another state, that joins the two by epsilon transitions.\r\n        const joiningStateRow: DeltaRow = {[Alphabet.EPSILON_CHAR]: [a.start,b.start  + shiftSize]};\r\n        const endingStateRow: DeltaRow = {};\r\n        // Join them up           \r\n        const delta: Delta = [...aDelta, ...bDelta, joiningStateRow, endingStateRow]\r\n            // object.assign applies each succesive element after the target object in a row. We start from a\r\n            // blank object, then apply our 'row template', and then apply our actual transitions.\r\n            // this ensures that each row has an array for each character in our alphabet.    \r\n            .map((transitionRowPartial: DeltaRow) => Object.assign({}, deltaRowTemplate, transitionRowPartial));\r\n\r\n        // set epsilon transitions between all former accept state and new single accept state.\r\n        ([...bAcceptShifted, ...a.accept]).forEach((index: number) => {\r\n            delta[index][Alphabet.EPSILON_CHAR].push(a.size + b.size + 1);\r\n        })\r\n        // the start state index after a and reindexed b are done\r\n        const startStateIndex = a.size + b.size;\r\n\r\n        return new NFA(sigma, delta, startStateIndex, [a.size + b.size + 1]);\r\n    }\r\n\r\n    // &\r\n    static concatenate(a: NFA, b: NFA) : NFA {\r\n        \r\n         // get the alphabet, row template, b shift value, origional a delta, and shifted b delta\r\n        const {sigma, deltaRowTemplate, shiftSize, aDelta, bDelta} = NFA.prepareOperations(a, b);\r\n\r\n        const bAcceptShifted = b.accept.map((state: number) => state + shiftSize);\r\n        const bStartShifted = b.start + shiftSize;\r\n    \r\n        const delta: Delta = [...aDelta, ...bDelta] \r\n            .map((transitionRowPartial: DeltaRow) => Object.assign({}, deltaRowTemplate, transitionRowPartial));\r\n       \r\n        // add epsilon transitions from all the accept states of a to the new start state of b \r\n        a.accept.forEach((state: number) => {\r\n            delta[state][Alphabet.EPSILON_CHAR].push(bStartShifted);\r\n        })\r\n\r\n        return new NFA(sigma, delta, a.start, bAcceptShifted)\r\n\r\n    }\r\n\r\n    // *\r\n    static star(a : NFA) : NFA {\r\n        let empty = NFA.EMPTY();\r\n        // star is a unary operator but i made the prepare ops function only work for binary fs. fortunately empty nfa acts\r\n        // like an identity here. \r\n        \r\n        const {sigma, deltaRowTemplate} = NFA.prepareOperations(empty, a);\r\n\r\n        // add a start and accept state\r\n        const joiningStateRow: DeltaRow = {[Alphabet.EPSILON_CHAR]: [a.start]};\r\n        const endingStateRow: DeltaRow = {[Alphabet.EPSILON_CHAR]: [a.start]};\r\n        \r\n        const delta = [...a.delta, joiningStateRow, endingStateRow]\r\n            .map((transitionRowPartial: DeltaRow) => Object.assign({}, deltaRowTemplate, transitionRowPartial));\r\n        \r\n        \r\n        // epsilon from all the old accepts to new accept state\r\n        a.accept.forEach((state: number) => {\r\n            delta[state][Alphabet.EPSILON_CHAR].push(a.size + 1);\r\n        })\r\n\r\n       return new NFA(sigma, delta, a.size, [0, a.size + 1]);\r\n\r\n    }\r\n    // ?\r\n    static maybe(a: NFA) : NFA {\r\n        // <expr>? = e | <expr>\r\n        return this.union(a, NFA.EPSILON());\r\n    }\r\n\r\n    static some(a: NFA) : NFA {\r\n        // <expr>+ = <expr><expr>*\r\n        return this.concatenate(a, this.star(a));\r\n    }\r\n\r\n    // returns a \"step\" through the delta table given a state and input char\r\n    follow (current: number[], char: string) : number[] {\r\n        return current.map(state => this.delta[state][char] || [])\r\n                      .filter(to => to && to.length > 0)\r\n                      .flat();\r\n    }\r\n    \r\n    // fixes epsilon closure\r\n    fixEpsilonClosure() : void {\r\n        for (let state = 0; state < this.size; state++) {\r\n            let current: number[] = [];\r\n            let next: number[] = [...this.follow([state], Alphabet.EPSILON_CHAR)].unique();\r\n            \r\n            // until we add 0 new, find states reachable by epsilon transition from our current ones\r\n            while (next.length !== current.length) {\r\n                current = next;\r\n                next = [...current, ...this.follow(current, Alphabet.EPSILON_CHAR)].unique();       \r\n            }\r\n            // assign all the ones found to current epsilon transition\r\n            this.delta[state][Alphabet.EPSILON_CHAR] = next;\r\n        }\r\n    }\r\n    eval (string: string) {\r\n        // evaluates a string to see if it matches\r\n        let inputChars: string[] = string.split('');\r\n        // we begin at start state\r\n        let currentStates: number[] = [this.start];\r\n        let nextStates: number[];\r\n        while (true) {\r\n            // go through all the epsilon transitions\r\n            nextStates = [...currentStates, ...this.follow(currentStates, Alphabet.EPSILON_CHAR)];\r\n            // get the next char. if we're done, check our current states to see if \r\n            // we're in an accept state\r\n            const char = inputChars.shift()\r\n            if (char === undefined) {\r\n                currentStates = nextStates;\r\n                break;\r\n            }\r\n            // follow all the current states by the input char\r\n            nextStates = this.follow(nextStates, char);\r\n            currentStates = nextStates;\r\n        }\r\n        // if there's any overlap between 'current' and 'accept', we have a match!\r\n        return this.accept.some(state => currentStates.indexOf(state) > -1);\r\n    }\r\n}\r\n\r\nexport { NFA, Alphabet, }","// Author justin lee & ben chong\r\n\r\nimport { NFA } from './nfa';\r\n\r\ninterface Operator {\r\n    precd: number,\r\n    astv: string,\r\n    arity: number,\r\n}\r\n\r\nconst OPS: Record<string, Operator> = {\r\n    ['|']: { precd: 1, astv: \"left\", arity: 2},\r\n    ['*']: { precd: 4, astv: \"right\", arity: 1},\r\n    ['&']: { precd: 2, astv: \"right\", arity: 2},\r\n    ['?']: { precd: 3, astv: \"left\", arity: 1},\r\n    ['+']: { precd: 3, astv: \"left\", arity: 1},\r\n    \r\n}\r\n\r\n//converts regex format from infix to postfix\r\nconst infixToPostfix = function(str: string) : string {\r\n\t\r\n    const opCompare = function(opStr1: string, opStr2: string) : number {\r\n    \treturn String.prototype.localeCompare.call(OPS[opStr1].precd, \"\"+OPS[opStr2].precd); \r\n    }\r\n\r\n    const outQueue: string[] = [];\r\n    const opStack : string[] = []; \r\n    \r\n    const getStackTop = function() : string {\r\n        return opStack[opStack.length - 1];\r\n    }\r\n\r\n    const shouldReduceOp = function(op: string) : boolean {\r\n    \tconst top: string = getStackTop();\r\n        if (!top || top === '(') return false;\r\n        const order: number = opCompare(top, op);\r\n        return  (order === 1 || (order === 0 && OPS[op].astv === \"left\"));\r\n    }\r\n    \r\n    const shouldReduceParen = function() : boolean {\r\n    \treturn getStackTop() !== '(';\r\n    }\r\n    // added expresion end met\r\n    let expressionEndMetArr: boolean[] = [];\r\n    let depth: number = 0;\r\n    let escapehatch:number = 50;\r\n    str.split('').forEach(char => {\r\n        if (! escapehatch) return;\r\n        switch (char) {\r\n            case '*':case '?':case'+':\r\n                outQueue.unshift('x');\r\n                while (shouldReduceOp(char)  && escapehatch--) {\r\n                    outQueue.unshift(opStack.pop() as string);\r\n                }\r\n                \r\n                expressionEndMetArr[depth] = true;\r\n                outQueue.unshift(char); break;\r\n            case '|': \r\n                while (shouldReduceOp(char)  && escapehatch--) {\r\n                    outQueue.unshift(opStack.pop() as string);\r\n                }\r\n                expressionEndMetArr[depth] = false;\r\n                opStack.push(char);\r\n                break;\r\n            case '(':\r\n                opStack.push(char);\r\n                \r\n                depth++;\r\n                expressionEndMetArr[depth] = false;\r\n                \r\n                break;\r\n            case ')':\r\n                while (shouldReduceParen() && escapehatch--) {\r\n                    outQueue.unshift(opStack.pop() as string);\r\n                }\r\n                depth--;\r\n\r\n                opStack.pop();\r\n                \r\n                if (expressionEndMetArr[depth]) opStack.push('&');\r\n                expressionEndMetArr[depth] = true;\r\n                \r\n                break;\r\n            default:\r\n                outQueue.unshift(char);\r\n                //if (getStackTop() === '*' || getStackTop() === '?') outQueue.unshift(opStack.pop() as string);\r\n                if (expressionEndMetArr[depth]) opStack.push('&');\r\n                expressionEndMetArr[depth] = true;\r\n        }\r\n    });\r\n\r\n    if (! escapehatch) return \"\";\r\n    let op;\r\n    while (op = opStack.pop()) outQueue.unshift(op);\r\n\treturn outQueue.reverse().join('');\r\n}\r\n\r\ninterface ExprTree<O, S> /* operator, symbol */ {\r\n    els: (S | ExprTree<O, S>)[],\r\n    op: O,\r\n}\r\n\r\n// author justin lee & ben chong\r\nconst postfixToTree = function(str: String, tr: ExprTree<string, string> = {els: [], op: '&'}) : ExprTree<string, string> | string {\r\n    const arr: string[] = str.split('');\r\n    const stack: (string | ExprTree<string, string>)[] = [];\r\n\r\n    const isOp = (char: string): boolean => Object.keys(OPS).indexOf(char) >= 0;\r\n    arr.forEach(char => {\r\n        if (isOp(char)) {\r\n            //let arity = OPS[char].arity;\r\n            let newTr = {\r\n                op: char,\r\n                els: stack.splice(-2/*arity*/),\r\n            };\r\n            stack.push(newTr);\r\n        } else {\r\n            stack.push(char);\r\n        }\r\n    });\r\n    let end = stack[0];\r\n    if (typeof end == \"string\" && end.length > 1) {\r\n        throw new Error('tree parsed incorrectly');\r\n    }\r\n    return end;\r\n}\r\n\r\n/*const treeToStateList = function(tree: ExprTree<string, string>| string) : string[] {\r\n    if (typeof tree == \"string\") return [tree];\r\n    switch (tree.op) {\r\n        case '|':\r\n            return [\r\n                \"open OR state\",\r\n                ... treeToStateList(tree.els[0]),\r\n                \"break OR state\",\r\n                ... treeToStateList(tree.els[1]),\r\n                \"close OR state\",\r\n            ]; \r\n        case '*':\r\n            return [\r\n                \"open kleine star\",\r\n                ... treeToStateList(tree.els[0]),\r\n                \"close kleine star\",\r\n            ];\r\n        case '&':\r\n            return [\r\n                ... treeToStateList(tree.els[0]),\r\n                ... treeToStateList(tree.els[1]),\r\n            ];\r\n        default: break;\r\n    }   \r\n}*/\r\n\r\n/*const findCloseState = function(arr: string[]) : [number, number] {\r\n\r\n    const stack: string[] = [];\r\n\r\n    if(arr[0] === \"open OR state\"){\r\n\r\n        let brk: number;\r\n        \r\n        for(let i = 0; i < arr.length; i++){\r\n\r\n            if(arr[i].length > 1){\r\n                if(arr[i] === \"close kleiene star\"){\r\n                    if(stack.pop() !== \"open kleiene star\"){\r\n                        return [-1, -1];\r\n                    }\r\n                }\r\n                else if(arr[i] === \"break OR state\"){\r\n                    if(stack.pop() !== \"open OR state\"){\r\n                        return [-1, -1];\r\n                    }\r\n                    if(stack.length == 0){\r\n                        brk = i;\r\n                    }\r\n                    stack.push(arr[i]);\r\n                }\r\n                else if(arr[i] === \"close OR state\"){\r\n                    if(stack.pop() !== \"break OR state\"){\r\n                        return [-1, -1];\r\n                    }\r\n                }\r\n                else{\r\n                    stack.push(arr[i]);\r\n                }\r\n            }\r\n\r\n            if(stack.length == 0){\r\n                return [i, brk];\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i = 0; i < arr.length; i++){\r\n        if(arr[i].length > 1){\r\n            if(arr[i] === \"close kleiene star\"){\r\n                if(stack.pop() !== \"open kleiene star\"){\r\n                    return [-1, -1];\r\n                }\r\n            }\r\n            else if(arr[i] === \"break OR state\"){\r\n                if(stack.pop() !== \"open OR state\"){\r\n                    return [-1, -1];\r\n                }\r\n                stack.push(arr[i]);\r\n            }\r\n            else if(arr[i] === \"close OR state\"){\r\n                if(stack.pop() !== \"break OR state\"){\r\n                    return [-1, -1];\r\n                }\r\n            }\r\n            else{\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n\r\n        if(stack.length == 0){\r\n            return [i, -1];\r\n        }\r\n    }\r\n}*/\r\n\r\n/*const stateListToNFA = function(arr: string[]) : NFA {\r\n    if(arr.length == 0){\r\n        return NFA.CHAR('');\r\n    }\r\n    if(arr[0].length > 1){\r\n        const [a, b] = findCloseState(arr);\r\n        if(b == -1){\r\n            return NFA.concatenate(NFA.star(stateListToNFA(arr.slice(1, a))), stateListToNFA(arr.slice(a+1)));\r\n        }\r\n        return NFA.concatenate(NFA.union(stateListToNFA(arr.slice(1, b)), stateListToNFA(arr.slice(b+1, a))), stateListToNFA(arr.slice(a+1)));;\r\n    }\r\n    return NFA.concatenate(NFA.CHAR(arr[0]), stateListToNFA(arr.slice(1)));\r\n}*/\r\n\r\n/*class NFA_{\r\n    s: string;\r\n\r\n    constructor(c: string){\r\n        this.s = c;\r\n    }\r\n\r\n    static union(a: NFA_, b: NFA_){\r\n        return new NFA_(\"(\" + a.s + \")|(\" + b.s + \")\");\r\n    }\r\n\r\n    static concatenate(a: NFA_, b: NFA_){\r\n        return new NFA_(\"(\" + a.s + \")&(\" + b.s + \")\");\r\n    }\r\n\r\n    static star(a: NFA_){\r\n        return new NFA_(\"(\" + a.s + \")*\");\r\n    }\r\n\r\n}*/\r\n\r\n// function author Ben Chong\r\nconst treeToNFA = function(tree: ExprTree<string, string>| string) : NFA {\r\n    if (typeof tree == \"string\") return NFA.CHAR(tree);\r\n    switch (tree.op) {\r\n        case '|':\r\n            return NFA.union(treeToNFA(tree.els[0]), treeToNFA(tree.els[1]));\r\n        case '*':\r\n            return NFA.star(treeToNFA(tree.els[0]));\r\n        case '?':\r\n            return NFA.maybe(treeToNFA(tree.els[0]));\r\n        case '+':\r\n            return NFA.some(treeToNFA(tree.els[0]));\r\n        case '&':\r\n            return NFA.concatenate(treeToNFA(tree.els[0]), treeToNFA(tree.els[1]));\r\n        default: break;\r\n    }\r\n    return NFA.CHAR(\"\");\r\n}\r\n\r\nconst convertRegexToNFAFunction = function(str: string) : (str: string) => boolean {\r\n    \r\n    try {\r\n        const fixed = infixToPostfix(str);\r\n        const tree = postfixToTree(fixed);\r\n        const nfa = treeToNFA(tree);\r\n        console.log({fixed, tree, nfa});\r\n        nfa.fixEpsilonClosure();\r\n        return nfa.eval.bind(nfa);\r\n    } catch (e) {\r\n        return (s: string) => false;\r\n    }\r\n}\r\nexport {\r\n    convertRegexToNFAFunction,\r\n}","import React from 'react';\r\n\r\nclass Intro extends React.Component {\r\n    render() {\r\n        return (\r\n            <div id=\"intro\">\r\n                String matcher by Justin Lee and Ben Chong\r\n                <br /><br />\r\n                Supports standard ops '(', ')', '*', '|'\r\n                <br />\r\n                      and additional ops '+' and '?'\r\n                <br /><br />\r\n\r\n                Press Enter to keep a result\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Intro;","//GUI .tsx\r\n// author Justin Lee november 24 2021.. late :)\r\n\r\nimport React from 'react';\r\nimport FancyTextarea from './FancyTextarea';\r\nimport { OutputRowProps } from './OutputRow';\r\nimport Display from './Display';\r\nimport { convertRegexToNFAFunction } from './regex';\r\nimport Intro from './Intro';\r\n\r\ninterface GUIProps { }\r\n\r\ninterface GUIState {\r\n    pattStr: string;\r\n    testStr: string;\r\n    success: boolean;\r\n    addToList: (props: OutputRowProps) => void;\r\n    evalFunction: (test: string) => boolean; \r\n}\r\nclass GUI extends React.Component<GUIProps, GUIState> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {\r\n            pattStr: \"\",\r\n            testStr: \"\",\r\n            addToList: (props: OutputRowProps) => 0,\r\n            success: false,\r\n            evalFunction: (test: string) => false,\r\n        };\r\n\r\n        this.on_patt_change = this.on_patt_change.bind(this);\r\n        this.on_test_change = this.on_test_change.bind(this);\r\n    }\r\n    on_patt_change(pattStr: string) {\r\n        this.setState({pattStr})\r\n        const evalFunction = convertRegexToNFAFunction(pattStr);\r\n        this.setState({evalFunction}, this.updateSuccessValue);\r\n\r\n    }\r\n\r\n    on_test_change(testStr: string) {\r\n        this.setState({testStr}, this.updateSuccessValue);\r\n\r\n    }\r\n    \r\n    updateSuccessValue() {\r\n        this.setState({success: this.state.evalFunction(this.state.testStr)})\r\n    }\r\n    \r\n    onKeyDown(e: any) {\r\n        if (e.keyCode === 13)\r\n            {\r\n            // prevent default behavior\r\n            e.preventDefault();\r\n            console.log(this.state.evalFunction);\r\n            const { pattStr, testStr, success } = this.state;\r\n            this.state.addToList({\r\n                pattStr, testStr, success\r\n            })\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <div id=\"holder_outer\" onKeyDown={(e) => this.onKeyDown(e)}>\r\n            <Intro />\r\n            <div className=\"holder\">\r\n                <FancyTextarea placeholder=\"Enter regex here...\" onchange={(e) => this.on_patt_change(e)} />\r\n                <FancyTextarea placeholder=\"Enter test string here...\" onchange={(e) => this.on_test_change(e)} />\r\n            </div>\r\n            <div className=\"holder\">\r\n                \r\n                    <Display success={this.state.success}pattStr={this.state.pattStr} testStr={this.state.testStr} \r\n                    setAddToList={(addToList: (props: OutputRowProps) => void) => {\r\n                        this.setState({addToList});\r\n                    }}\r\n                    />\r\n    \r\n            </div>\r\n        </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GUI;\r\n","//  Justin lee author of all website related files\n\nimport GUI from './GUIComp';\n\nfunction App() {\n  return (\n    <div className=\"App\">        \n        <GUI />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n\n"],"sourceRoot":""}