{"version":3,"sources":["FancyTextarea.tsx","OutputRow.tsx","OutputList.tsx","Display.tsx","nfa.ts","regex.ts","Intro.tsx","GUIComp.tsx","App.tsx","index.tsx"],"names":["FancyTextarea","e","contents","target","value","this","props","onchange","className","placeholder","onChange","React","Component","OutputRow","pattStr","testStr","success","OutputList","state","propsList","addToList","bind","setAddToList","unshift","setState","map","Display","outputList","id","Array","prototype","unique","Set","deepReverse","reverse","el","isArray","Object","complexmap","f","obj","i","entries","key","hasOwnProperty","Alphabet","chars","charList","EPSILON_CHAR","split","filter","char","OPS","has","join","console","log","l","length","next","done","string","Error","indexOf","fromEntries","other","getCharList","a","b","Symbol","iterator","EMPTY","EPSILON","NFA","sigma","delta","start","accept","size","current","to","flat","follow","nextStates","inputChars","currentStates","shift","undefined","some","str","d","shiftSize","transitionRow","states","transitionChar","reindexDelta","union","deltaRowTemplate","getRowTemplate","bDelta","aDelta","prepareOperations","bAcceptShifted","joiningStateRow","transitionRowPartial","assign","forEach","index","push","joinStateIndex","bStartShifted","empty","endingStateRow","concatenate","star","CHAR","c","ab","cd","aborcd","final","fixEpsilonClosure","eval","precd","astv","arity","infixToPostfix","op","outQueue","opStack","getStackTop","shouldReduceOp","top","opStr1","opStr2","order","String","localeCompare","call","expressionEndMetArr","depth","escapehatch","pop","treeToNFA","tree","els","maybe","convertRegexToNFAFunction","fixed","arr","stack","isOp","keys","newTr","splice","end","postfixToTree","nfa","s","Intro","GUI","evalFunction","test","on_patt_change","on_test_change","updateSuccessValue","keyCode","preventDefault","onKeyDown","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fe38f2e9.chunk.js","sourcesContent":["import React from 'react';\r\n\r\ninterface TextareaProps {\r\n    placeholder: string;\r\n    onchange: (str: string) => void;\r\n}\r\n\r\ninterface TextareaState { }\r\n\r\nclass FancyTextarea extends React.Component<TextareaProps, TextareaState> {\r\n\r\n    onchange (e: any) {\r\n        const contents = e.target.value;\r\n        \r\n        this.props.onchange(contents);\r\n    }\r\n\r\n \r\n    \r\n    render () {\r\n        return (\r\n            <div className = \"textarea_outer\">\r\n                <textarea     data-gramm=\"false\" placeholder={this.props.placeholder}  onChange={(e) => this.onchange(e)}></textarea>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\nexport default FancyTextarea;","import React from 'react';\r\n\r\ninterface OutputRowProps {\r\n    pattStr: string;\r\n    testStr: string;\r\n    success: boolean;\r\n}\r\n\r\ninterface OutputRowState { }\r\nclass OutputRow extends React.Component<OutputRowProps, OutputRowState> {\r\n    render() {\r\n        const {pattStr, testStr} = this.props;\r\n        return (\r\n            <tr className=\"output_row\">\r\n                <td>{pattStr ? `/${pattStr}/` : \"(empty)\"}</td>\r\n                <td>{testStr ? `\"${testStr}\"` : \"(empty)\"}</td>\r\n                <td className={\"success_\"+this.props.success}>{this.props.success ? \"Accept\" : \"Reject\"}</td>\r\n            </tr>\r\n        )\r\n    }\r\n}\r\n\r\nexport default OutputRow;\r\n\r\nexport type {\r\n    OutputRowProps\r\n}","import React from 'react';\r\nimport OutputRow, {OutputRowProps} from './OutputRow';\r\n\r\ninterface OutputListProps {    \r\n    setAddToList: (f: (props: OutputRowProps) => void) => void;\r\n}\r\n\r\ninterface OutputListState {\r\n    propsList: OutputRowProps[];\r\n}\r\n\r\nclass OutputList extends React.Component<OutputListProps, OutputListState> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {\r\n            propsList: [],\r\n        }\r\n        this.addToList = this.addToList.bind(this);\r\n        this.props.setAddToList(this.addToList);\r\n    }\r\n    \r\n    addToList(props: OutputRowProps) {\r\n        \r\n        const propsList = this.state.propsList;\r\n        propsList.unshift(props);\r\n        this.setState({ propsList });\r\n    }\r\n\r\n    render() {\r\n        return this.state.propsList.map(({pattStr, testStr, success}) => \r\n        <OutputRow pattStr={pattStr} testStr={testStr} success={success} />\r\n        )\r\n    }    \r\n}\r\n\r\nexport default OutputList","import React from 'react';\r\n\r\nimport OutputRow, {OutputRowProps} from './OutputRow';\r\nimport OutputList from './OutputList';\r\n\r\ninterface DisplayProps {\r\n    pattStr: string;\r\n    testStr: string;\r\n    success: boolean;\r\n    setAddToList: (f: (props: OutputRowProps) => void) => void;\r\n\r\n}\r\n\r\ninterface DisplayState {\r\n    outputList: OutputRowProps[];\r\n    addToList: (props: OutputRowProps) => void; \r\n}\r\n\r\nclass Display extends React.Component<DisplayProps, DisplayState> {\r\n    constructor(props: DisplayProps) {\r\n        super(props);\r\n        const {pattStr, testStr, success} = props;\r\n        this.state = {\r\n            outputList: [{\r\n                pattStr, testStr, success,\r\n            }],\r\n            addToList: (props: OutputRowProps) => 0,\r\n        }\r\n    }\r\n    \r\n    \r\n    addToList (props: OutputRowProps) {\r\n        return this.state.addToList(props);\r\n    }\r\n    \r\n    render() {\r\n\r\n        const {pattStr, testStr, success} = this.props;\r\n\r\n        return (\r\n            <table id=\"displayTable\">\r\n            <OutputRow pattStr={pattStr} testStr={testStr} success={success} />\r\n            <OutputList setAddToList={(addToList: (props: OutputRowProps) => void) => {\r\n                this.setState({addToList});\r\n                this.props.setAddToList(addToList);\r\n            }}/> \r\n            </table>\r\n        )\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default Display;","// Author justin lee oct nov 2021\r\n// recommented nov 2021 to add more expanation\r\ndeclare global {\r\n    interface Array<T> {\r\n        deepReverse(): Array<T>;\r\n        unique(): Array<T>;\r\n    }\r\n\r\n    interface Object {\r\n        complexmap<T, Q>(f: (value: T, key?: string | number | symbol, index?: number) => Q) : Record<any, any>;\r\n    }\r\n}\r\n\r\nArray.prototype.unique = function() : Array<any> {\r\n    return [ ...new Set(this)];\r\n    // only works for primitives\r\n}\r\nArray.prototype.deepReverse = function() {\r\n    return this.reverse().map(function(el: any) {\r\n        if (Array.isArray(el)) return el.deepReverse();\r\n        return el;\r\n    })\r\n}\r\n\r\nObject.prototype.complexmap = function<T, Q>( f: (value: T, key?: string | number | symbol, index?: number) => Q) : Record<any, Q> {\r\n// I kept modifying the structure of the delta tables cause i was indecisive and it was confusing to have to keep changing map. so i made a general map\r\n    let obj: Record<any, Q> = {}; let i = 0;\r\n    \r\n    for (let [key, value] of Object.entries(this)) {\r\n        if (!this.hasOwnProperty(key)) continue;\r\n        obj[key] = f(value as T, key, i++);\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\ntype DeltaRow = Record<string, number[]>\r\ntype Delta = DeltaRow[]; // an array of objects whos keys are strings (chars) and whos values are arrays of numbers (integers);\r\n\r\ntype StructString = string | StructString[];\r\nconst fixParen = function(arr: StructString[], depths: number[] = []) : StructString[] {\r\n\r\n    let empty = depths.length === 0;\r\n    console.log({\r\n        toRead: arr[0],\r\n        depths: empty ? 'empty' : depths.join(', '),\r\n    });\r\n\r\n    let newArr: StructString = [];\r\n    if (depths[0] === 0) {\r\n        depths.shift();\r\n        arr.unshift('(');\r\n        }    //return newArr;\r\n    if (!arr[0]) return [];\r\n    let el: StructString = arr.shift() as StructString; \r\n    \r\n    switch (el) {\r\n        case ')': case undefined: \r\n            //if (!empty) {\r\n               // depths[0]--; \r\n                arr.unshift('(');\r\n            //}\r\n\t\t\treturn newArr;\r\n        case '(':\r\n            //if (!empty) depths[0]++;\r\n            newArr.push(fixParen(arr, depths)); break;            \r\n\t\tcase '*':\r\n            arr.unshift('#');\r\n                    depths.push(0);\r\n            newArr.push(fixParen(arr, depths));\r\n     break;\r\n        default:\r\n            newArr.push(el);      \r\n    }   \r\n\r\n    return newArr.concat(fixParen(arr, depths));\r\n}\r\n\r\n//let str = \"ab(a|b)a*ab(ab)\";\r\n//let arr = str.split('').reverse();\r\n//let fixed = fixParen(arr);\r\n//console.log(fixed.deepReverse());\r\n\r\n\r\n/*enum OPS {\r\n    STAR = '*',\r\n    OPEN_PAREN = '(',\r\n    CLOSE_PAREN = ')',\r\n    OR = '|',\r\n    EPSILON = `~`\r\n}/*\r\nconst enum CharBrand {};\r\ntype Char = string & CharBrand;\r\nnamespace Char {\r\n    toCharArray(string: string) : Char[]\r\n}\r\n\r\n*/\r\nclass Alphabet {\r\n    private charList: string[] = [];\r\n    \r\n    static readonly OPS = new Set('*()|~'.split(''));\r\n\r\n    static readonly EPSILON_CHAR = '%';\r\n    static readonly EMPTY = new Alphabet(\"\", false);\r\n    static readonly EPSILON = new Alphabet(\"\", true);\r\n\r\n    \r\n    constructor(chars: string, epsilon= true) {\r\n        this.charList = (chars + Alphabet.EPSILON_CHAR)\r\n            .split('')\r\n            .filter(char => ! Alphabet.OPS.has(char))\r\n            .unique();\r\n        //if (epsilon) this.charList.push(\"%\");\r\n            // Get all the unique characters that aren't operators\r\n    }\r\n\r\n\r\n    getCharList() : string {\r\n        return this.charList.join(''); // shallow copy because entries are primitives\r\n    }\r\n    debug () : void {\r\n    \tconsole.log(`Alphabet: '` + this.charList.join(`', '`) + `'`);\r\n    }\r\n    \r\n    // so i can loop through the alphabet using for... of\r\n    [Symbol.iterator]() {\r\n        let i = 0, l = this.charList.length;\r\n        return ({\r\n            next: () => ({\r\n                done: l === i + 1,\r\n                value: this.charList[i++],\r\n            })\r\n        });\r\n    }\r\n\r\n    //check char presence in Alphabet.\r\n    has (string: string) : boolean {\r\n        if (string.length !== 1) throw new Error(\"chars can only be of length 1\");\r\n        return this.charList.indexOf(string) >= 0;\r\n    }\r\n\r\n    getRowTemplate() : DeltaRow {\r\n        return Object.fromEntries(this.charList.map(char => [char, []]));\r\n    }\r\n\r\n    equals (other: Alphabet) : boolean {\r\n        return this.getCharList() === other.getCharList();\r\n    }\r\n\r\n    static union(a: Alphabet, b: Alphabet) : Alphabet { \r\n        return new Alphabet(a.getCharList() + b.getCharList());\r\n    }\r\n}\r\n\r\n//const isDelta = function(arr: object[]) : arr is Delta {\r\n //   let \r\n//}\r\n\r\n\r\n\r\n\r\n/*\r\nfunction complexmap<Q>(types: Function[], obj: any, f: Function, parents: any[] = []) : Q {\r\n    const [thisType, ...restTypes] = types;\r\n    console.log(thisType);\r\n    let mapF: Function;\r\n    switch (thisType) {\r\n        case undefined: \r\n            return f(obj);\r\n        case Array: // have got to fix\r\n            mapF = Array.prototype.map; break;\r\n        case Object: \r\n            console.log(\"object\");\r\n            mapF = Object.prototype.complexmap; break;\r\n        default:\r\n            throw new Error(\"encountererd an invalid type\");\r\n    }\r\n\r\n    if (! (obj instanceof thisType)) throw new Error (`Provided object did not ascribe to given type scheme: ${typeof obj} not in ${thisType}`)\r\n   \r\n    console.log(\"mapf\", mapF);\r\n\r\n    return mapF.call(obj, (value: typeof restTypes[1], key: any) => complexmap(restTypes, value, f, [{container: obj, key}, ...parents]));\r\n\r\n}*/\r\n/*dunction getComplexMap(types: Function[], f: Function, parents: any[] = []) : Function {\r\n    const [thisType, ...restTypes] = types;\r\n    console.log(thisType);\r\n    let mapF: Function;\r\n    switch (thisType) {\r\n        case undefined: \r\n            return f;\r\n        case Array: // map and our custom map is defined on array and object types... nice :)\r\n            mapF = Array.prototype.map; break;\r\n        case Object: \r\n            console.log(\"object\");\r\n            mapF = Object.prototype.complexmap; break;\r\n        default:\r\n            throw new Error(\"encountererd an invalid type\");\r\n    }\r\n\r\n    //if (! (obj instanceof thisType)) throw new Error (`Provided object did not ascribe to given type scheme: ${typeof obj} not in ${thisType}`)\r\n   \r\n    console.log(\"mapf\", mapF);\r\n\r\n    return (obj: any) => mapF.call(obj, (value: typeof restTypes[1], key: any) => complexmap(restTypes, value, f, [{container: obj, key}, ...parents]));\r\n\r\n}*/\r\n/*\r\nObject.prototype.ascribeStructure = function(types: Function[]) {\r\n    \r\n    map: function(f: Function) {\r\n        \r\n    }\r\n    return {\r\n        thisObj: this,\r\n        \r\n    }\r\n}\r\n*/\r\n//let m = complexmap([Object, Array], {a: [1, 2, 3, 4, 5], b: [2, 9]}, (x: any) => x*2);\r\n\r\n//console.log(m);\r\n//console.log([1, 2, 3])\r\nclass NFA {\r\n    \r\n    readonly size: number; \r\n\r\n    static readonly EPSILON = () => new NFA(Alphabet.EPSILON, [{[Alphabet.EPSILON_CHAR]: []}], 0, [0]);\r\n\r\n    static readonly EMPTY = () => new NFA(Alphabet.EPSILON, [], -12345678, []);\r\n\r\n    static CHAR(str: string) {\r\n        return new NFA(new Alphabet(str), [{[str]: [1], [Alphabet.EPSILON_CHAR]: []}, {[str]: [], [Alphabet.EPSILON_CHAR]: []}], 0, [1]);\r\n    }\r\n\r\n    static reindexDelta(d: Delta, shiftSize: number) {\r\n        return d.map((transitionRow: DeltaRow) => transitionRow\r\n                .complexmap<number[], number[]>((states: number[], transitionChar) => states \r\n                    .map((state: number) => state + shiftSize)));\r\n    }\r\n\r\n    static copyDelta(d: Delta) {\r\n        return NFA.reindexDelta(d, 0);\r\n    }\r\n\r\n    /*static prepareOperations(list: Record<string, NFA>) {\r\n        const globals = Object.entries(list).reduce(function(obj, [name, thisNfa]) {\r\n            const shift = obj.delta.length;\r\n            return {\r\n                sigma: Alphabet.union(obj.sigma, thisNfa.sigma),\r\n                delta\r\n            }\r\n        }, {\r\n            sigma: Alphabet.EMPTY,\r\n            delta:[],\r\n        });\r\n\r\n    }*/\r\n    static prepareOperations(a: NFA, b: NFA) {\r\n        // Create a new alphabet, with the characters of both.\r\n        const sigma = Alphabet.union(a.sigma, b.sigma);\r\n        // Create an object to build off of, that looks like a row (state) of transitions.\r\n        const deltaRowTemplate = sigma.getRowTemplate();\r\n\r\n        // We're making an array to add them together, so we've got to shift the indices of the second set of \r\n        // states over\r\n        const shiftSize = a.size;\r\n        const bDelta = NFA.reindexDelta(b.delta, shiftSize);\r\n\r\n        const aDelta = NFA.reindexDelta(a.delta, 0);\r\n\r\n            // Mapping on each \"from\" state, then on each character, then on each \"to\" state, to adjust\r\n            // state values by the shiftSize\r\n           \r\n        return {\r\n            sigma,\r\n            deltaRowTemplate,\r\n            shiftSize,\r\n            aDelta,\r\n            bDelta,\r\n           // bStartShifted\r\n        }\r\n    }\r\n    static union(a: NFA, b: NFA) : NFA {\r\n        \r\n        const {sigma, deltaRowTemplate, shiftSize, aDelta, bDelta} = NFA.prepareOperations(a, b);\r\n\r\n        const bAcceptShifted = b.accept.map((state: number) => state + shiftSize);\r\n        // We create another state, that joins the two by epsilon transitions.\r\n        const joiningStateRow: DeltaRow = {[Alphabet.EPSILON_CHAR]: [a.start,b.start  + shiftSize]};\r\n        const endingStateRow: DeltaRow = {};\r\n        // Join them up           \r\n        const delta: Delta = [...aDelta, ...bDelta, joiningStateRow, endingStateRow]\r\n            // object.assign applies each succesive element after the target object in a row. We start from a\r\n            // blank object, then apply our 'row template', and then apply our actual transitions.\r\n            // this ensures that each row has an array for each character in our alphabet.    \r\n            .map((transitionRowPartial: DeltaRow) => Object.assign({}, deltaRowTemplate, transitionRowPartial));\r\n        // Our new state that joins the two is our new start state\r\n\r\n        ([...bAcceptShifted, ...a.accept]).forEach((index: number) => {\r\n            delta[index][Alphabet.EPSILON_CHAR].push(a.size + b.size + 1);\r\n        })\r\n        const joinStateIndex = a.size + b.size;\r\n\r\n        return new NFA(sigma, delta, joinStateIndex, [a.size + b.size + 1]);\r\n    }\r\n\r\n    static concatenate(a: NFA, b: NFA) : NFA {\r\n        const {sigma, deltaRowTemplate, shiftSize, aDelta, bDelta} = NFA.prepareOperations(a, b);\r\n\r\n        const bAcceptShifted = b.accept.map((state: number) => state + shiftSize);\r\n        const bStartShifted = b.start + shiftSize;\r\n    \r\n        const delta: Delta = [...aDelta, ...bDelta] \r\n            .map((transitionRowPartial: DeltaRow) => Object.assign({}, deltaRowTemplate, transitionRowPartial));\r\n       \r\n        a.accept.forEach((state: number) => {\r\n            delta[state][Alphabet.EPSILON_CHAR].push(bStartShifted);\r\n        })\r\n        return new NFA(sigma, delta, a.start, bAcceptShifted)\r\n    }\r\n\r\n    static star(a : NFA) : NFA {\r\n        let empty = NFA.EMPTY();\r\n        // star is a unary operator but i made the prepare ops function binary. fortunately empty nfa acts\r\n        // like an identity here. \r\n        \r\n        const {sigma, deltaRowTemplate} = NFA.prepareOperations(empty, a);\r\n        \r\n        //const bAcceptShifted = b.accept.map((state: number) => state + shiftSize);\r\n        //const bStartShifted = b.start + shiftSize;\r\n        const joiningStateRow: DeltaRow = {[Alphabet.EPSILON_CHAR]: [a.start]};\r\n        const endingStateRow: DeltaRow = {[Alphabet.EPSILON_CHAR]: [a.start]};\r\n        \r\n        \r\n         const delta = [...a.delta, joiningStateRow, endingStateRow]\r\n            .map((transitionRowPartial: DeltaRow) => Object.assign({}, deltaRowTemplate, transitionRowPartial));\r\n        \r\n        a.accept.forEach((state: number) => {\r\n            delta[state][Alphabet.EPSILON_CHAR].push(a.size + 1);\r\n        })\r\n            // this is\r\n       //delta[0][Alphabet.EPSILON_CHAR].push(bStartShifted);\r\n       //bAcceptShifted.forEach((state: number) => {\r\n         //  delta[state][Alphabet.EPSILON_CHAR].push(0);\r\n       //})\r\n\r\n       return new NFA(sigma, delta, a.size, [0, a.size + 1]);\r\n    }\r\n    \r\n    static maybe(a: NFA) : NFA {\r\n        return this.union(a, NFA.EPSILON());\r\n    }\r\n\r\n    static some(a: NFA) : NFA {\r\n        return this.concatenate(a, this.star(a));\r\n    }\r\n    constructor(protected readonly sigma: Alphabet, protected readonly delta: Delta, protected readonly start: number, protected readonly accept: number[]) {\r\n      this.size = this.delta.length;\r\n    }\r\n\r\n    follow (current: number[], char: string) : number[] {\r\n        return current.map(state => this.delta[state][char] || [])\r\n                      .filter(to => to && to.length > 0)\r\n                      .flat();\r\n    }\r\n    fixEpsilonClosure() : void {\r\n        for (let state = 0; state < this.size; state++) {\r\n            let current: number[] = [];\r\n            let next: number[] = [...this.follow([state], Alphabet.EPSILON_CHAR)].unique();\r\n            while (next.length !== current.length) {\r\n                current = next;\r\n                next = [...current, ...this.follow(current, Alphabet.EPSILON_CHAR)].unique();\r\n\r\n                \r\n            }\r\n            this.delta[state][Alphabet.EPSILON_CHAR] = next;\r\n        }\r\n    }\r\n    eval (string: string) {\r\n        let inputChars: string[] = string.split('');\r\n        let currentStates: number[] = [this.start];\r\n        let nextStates: number[];\r\n        while (true) {\r\n            nextStates = [...currentStates, ...this.follow(currentStates, Alphabet.EPSILON_CHAR)];\r\n            const char = inputChars.shift()\r\n            if (char === undefined) {\r\n                currentStates = nextStates;\r\n                break;\r\n            }\r\n            nextStates = this.follow(nextStates, char);\r\n            currentStates = nextStates;\r\n        }\r\n        return this.accept.some(state => currentStates.indexOf(state) > -1);\r\n    }\r\n}\r\n\r\n\r\n\r\nlet a = NFA.CHAR(\"a\");\r\nlet b = NFA.CHAR(\"b\");\r\nlet c = NFA.CHAR(\"c\");\r\nlet d = NFA.CHAR(\"d\");\r\nlet ab = NFA.concatenate(a, b);\r\nlet cd = NFA.concatenate(c, d);\r\nlet aborcd = NFA.union(ab, cd);\r\nlet final = NFA.star(aborcd);\r\n\r\n// (ab|cd)*\r\nfinal.fixEpsilonClosure();\r\n\r\n//let L6 = NFA.star(L5);\r\n//let L5 = NFA.union(L4, L3);\r\n\r\nfinal.fixEpsilonClosure();\r\n//console.log(final);\r\n[\"\", \"ab\", \"cd\", \"ac\", \"bd\", \"abc\", \"abcda\", \"ababcd\", \"abcdcdcd\"].forEach(function(str) {\r\n    console.log(str + \", \" + final.eval(str));\r\n})\r\n\r\nexport { NFA, Alphabet, }","import { NFA } from './nfa';\r\n\r\ninterface Operator {\r\n    precd: number,\r\n    astv: string,\r\n    arity: number,\r\n}\r\n\r\nconst OPS: Record<string, Operator> = {\r\n    ['|']: { precd: 1, astv: \"left\", arity: 2},\r\n    ['*']: { precd: 4, astv: \"right\", arity: 1},\r\n    ['&']: { precd: 2, astv: \"right\", arity: 2},\r\n    ['?']: { precd: 3, astv: \"left\", arity: 1},\r\n    ['+']: { precd: 3, astv: \"left\", arity: 1},\r\n    \r\n}\r\n\r\n//converts regex format from infix to postfix\r\n//ex. a|b -> ab|\r\nconst infixToPostfix = function(str: string) : string {\r\n\t\r\n    const opCompare = function(opStr1: string, opStr2: string) : number {\r\n    \treturn String.prototype.localeCompare.call(OPS[opStr1].precd, \"\"+OPS[opStr2].precd); \r\n    }\r\n\r\n    const outQueue: string[] = [];\r\n    const opStack : string[] = []; \r\n    \r\n    const getStackTop = function() : string {\r\n        return opStack[opStack.length - 1];\r\n    }\r\n\r\n    const shouldReduceOp = function(op: string) : boolean {\r\n    \tconst top: string = getStackTop();\r\n        if (!top || top === '(') return false;\r\n        const order: number = opCompare(top, op);\r\n        return  (order === 1 || (order === 0 && OPS[op].astv === \"left\"));\r\n    }\r\n    \r\n    const shouldReduceParen = function() : boolean {\r\n    \treturn getStackTop() !== '(';\r\n    }\r\n    // added expresion end met\r\n    let expressionEndMetArr: boolean[] = [];\r\n    let depth: number = 0;\r\n    let escapehatch:number = 50;\r\n    str.split('').forEach(char => {\r\n        if (! escapehatch) return;\r\n        switch (char) {\r\n            case '*':case '?':case'+':\r\n                outQueue.unshift('x');\r\n                while (shouldReduceOp(char)  && escapehatch--) {\r\n                    outQueue.unshift(opStack.pop() as string);\r\n                }\r\n                \r\n                expressionEndMetArr[depth] = true;\r\n                outQueue.unshift(char); break;\r\n            case '|': \r\n                while (shouldReduceOp(char)  && escapehatch--) {\r\n                    outQueue.unshift(opStack.pop() as string);\r\n                }\r\n                expressionEndMetArr[depth] = false;\r\n                opStack.push(char);\r\n                break;\r\n            case '(':\r\n                opStack.push(char);\r\n                \r\n                depth++;\r\n                expressionEndMetArr[depth] = false;\r\n                \r\n                break;\r\n            case ')':\r\n                while (shouldReduceParen() && escapehatch--) {\r\n                    outQueue.unshift(opStack.pop() as string);\r\n                }\r\n                depth--;\r\n\r\n                opStack.pop();\r\n                \r\n                if (expressionEndMetArr[depth]) opStack.push('&');\r\n                expressionEndMetArr[depth] = true;\r\n                \r\n                break;\r\n            default:\r\n                outQueue.unshift(char);\r\n                //if (getStackTop() === '*' || getStackTop() === '?') outQueue.unshift(opStack.pop() as string);\r\n                if (expressionEndMetArr[depth]) opStack.push('&');\r\n                expressionEndMetArr[depth] = true;\r\n        }\r\n    });\r\n\r\n    if (! escapehatch) return \"\";\r\n    let op;\r\n    while (op = opStack.pop()) outQueue.unshift(op);\r\n\treturn outQueue.reverse().join('');\r\n}\r\n\r\ninterface ExprTree<O, S> /* operator, symbol */ {\r\n    els: (S | ExprTree<O, S>)[],\r\n    op: O,\r\n}\r\n\r\n//converts from a postfix regex to an expression tree\r\nconst postfixToTree = function(str: String, tr: ExprTree<string, string> = {els: [], op: '&'}) : ExprTree<string, string> | string {\r\n    const arr: string[] = str.split('');\r\n    const stack: (string | ExprTree<string, string>)[] = [];\r\n\r\n    const isOp = (char: string): boolean => Object.keys(OPS).indexOf(char) >= 0;\r\n    arr.forEach(char => {\r\n        if (isOp(char)) {\r\n            //let arity = OPS[char].arity;\r\n            let newTr = {\r\n                op: char,\r\n                els: stack.splice(-2/*arity*/),\r\n            };\r\n            stack.push(newTr);\r\n        } else {\r\n            stack.push(char);\r\n        }\r\n    });\r\n    let end = stack[0];\r\n    if (typeof end == \"string\" && end.length > 1) {\r\n        throw new Error('tree parsed incorrectly');\r\n    }\r\n    return end;\r\n}\r\n\r\n/*const treeToStateList = function(tree: ExprTree<string, string>| string) : string[] {\r\n    if (typeof tree == \"string\") return [tree];\r\n    switch (tree.op) {\r\n        case '|':\r\n            return [\r\n                \"open OR state\",\r\n                ... treeToStateList(tree.els[0]),\r\n                \"break OR state\",\r\n                ... treeToStateList(tree.els[1]),\r\n                \"close OR state\",\r\n            ]; \r\n        case '*':\r\n            return [\r\n                \"open kleine star\",\r\n                ... treeToStateList(tree.els[0]),\r\n                \"close kleine star\",\r\n            ];\r\n        case '&':\r\n            return [\r\n                ... treeToStateList(tree.els[0]),\r\n                ... treeToStateList(tree.els[1]),\r\n            ];\r\n        default: break;\r\n    }   \r\n}*/\r\n\r\n/*const findCloseState = function(arr: string[]) : [number, number] {\r\n\r\n    const stack: string[] = [];\r\n\r\n    if(arr[0] === \"open OR state\"){\r\n\r\n        let brk: number;\r\n        \r\n        for(let i = 0; i < arr.length; i++){\r\n\r\n            if(arr[i].length > 1){\r\n                if(arr[i] === \"close kleiene star\"){\r\n                    if(stack.pop() !== \"open kleiene star\"){\r\n                        return [-1, -1];\r\n                    }\r\n                }\r\n                else if(arr[i] === \"break OR state\"){\r\n                    if(stack.pop() !== \"open OR state\"){\r\n                        return [-1, -1];\r\n                    }\r\n                    if(stack.length == 0){\r\n                        brk = i;\r\n                    }\r\n                    stack.push(arr[i]);\r\n                }\r\n                else if(arr[i] === \"close OR state\"){\r\n                    if(stack.pop() !== \"break OR state\"){\r\n                        return [-1, -1];\r\n                    }\r\n                }\r\n                else{\r\n                    stack.push(arr[i]);\r\n                }\r\n            }\r\n\r\n            if(stack.length == 0){\r\n                return [i, brk];\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i = 0; i < arr.length; i++){\r\n        if(arr[i].length > 1){\r\n            if(arr[i] === \"close kleiene star\"){\r\n                if(stack.pop() !== \"open kleiene star\"){\r\n                    return [-1, -1];\r\n                }\r\n            }\r\n            else if(arr[i] === \"break OR state\"){\r\n                if(stack.pop() !== \"open OR state\"){\r\n                    return [-1, -1];\r\n                }\r\n                stack.push(arr[i]);\r\n            }\r\n            else if(arr[i] === \"close OR state\"){\r\n                if(stack.pop() !== \"break OR state\"){\r\n                    return [-1, -1];\r\n                }\r\n            }\r\n            else{\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n\r\n        if(stack.length == 0){\r\n            return [i, -1];\r\n        }\r\n    }\r\n}*/\r\n\r\n/*const stateListToNFA = function(arr: string[]) : NFA {\r\n    if(arr.length == 0){\r\n        return NFA.CHAR('');\r\n    }\r\n    if(arr[0].length > 1){\r\n        const [a, b] = findCloseState(arr);\r\n        if(b == -1){\r\n            return NFA.concatenate(NFA.star(stateListToNFA(arr.slice(1, a))), stateListToNFA(arr.slice(a+1)));\r\n        }\r\n        return NFA.concatenate(NFA.union(stateListToNFA(arr.slice(1, b)), stateListToNFA(arr.slice(b+1, a))), stateListToNFA(arr.slice(a+1)));;\r\n    }\r\n    return NFA.concatenate(NFA.CHAR(arr[0]), stateListToNFA(arr.slice(1)));\r\n}*/\r\n\r\n/*class NFA_{\r\n    s: string;\r\n\r\n    constructor(c: string){\r\n        this.s = c;\r\n    }\r\n\r\n    static union(a: NFA_, b: NFA_){\r\n        return new NFA_(\"(\" + a.s + \")|(\" + b.s + \")\");\r\n    }\r\n\r\n    static concatenate(a: NFA_, b: NFA_){\r\n        return new NFA_(\"(\" + a.s + \")&(\" + b.s + \")\");\r\n    }\r\n\r\n    static star(a: NFA_){\r\n        return new NFA_(\"(\" + a.s + \")*\");\r\n    }\r\n\r\n}*/\r\n\r\nconst treeToNFA = function(tree: ExprTree<string, string>| string) : NFA {\r\n    if (typeof tree == \"string\") return NFA.CHAR(tree);\r\n    switch (tree.op) {\r\n        case '|':\r\n            return NFA.union(treeToNFA(tree.els[0]), treeToNFA(tree.els[1]));\r\n        case '*':\r\n            return NFA.star(treeToNFA(tree.els[0]));\r\n        case '?':\r\n            return NFA.maybe(treeToNFA(tree.els[0]));\r\n        case '+':\r\n            return NFA.some(treeToNFA(tree.els[0]));\r\n        case '&':\r\n            return NFA.concatenate(treeToNFA(tree.els[0]), treeToNFA(tree.els[1]));\r\n        default: break;\r\n    }\r\n    return NFA.CHAR(\"\");\r\n}\r\n\r\nconst convertRegexToNFAFunction = function(str: string) : (str: string) => boolean {\r\n    \r\n    try {\r\n        const fixed = infixToPostfix(str);\r\n        const tree = postfixToTree(fixed);\r\n        const nfa = treeToNFA(tree);\r\n        console.log({fixed, tree, nfa});\r\n        nfa.fixEpsilonClosure();\r\n        return nfa.eval.bind(nfa);\r\n    } catch (e) {\r\n        return (s: string) => false;\r\n    }\r\n}\r\nexport {\r\n    convertRegexToNFAFunction,\r\n}","import React from 'react';\r\n\r\nclass Intro extends React.Component {\r\n    render() {\r\n        return (\r\n            <div id=\"intro\">\r\n                String matcher by Justin Lee and Ben Chong\r\n                <br /><br />\r\n                Supports standard ops '(', ')', '*', '|'\r\n                <br />\r\n                      and additional ops '+' and '?'\r\n                <br /><br />\r\n\r\n                Press Enter to keep a result\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Intro;","//GUI .tsx\r\n// author Justin Lee november 24 2021.. late :)\r\n\r\nimport React from 'react';\r\nimport FancyTextarea from './FancyTextarea';\r\nimport { OutputRowProps } from './OutputRow';\r\nimport Display from './Display';\r\nimport { convertRegexToNFAFunction } from './regex';\r\nimport Intro from './Intro';\r\n\r\ninterface GUIProps { }\r\n\r\ninterface GUIState {\r\n    pattStr: string;\r\n    testStr: string;\r\n    success: boolean;\r\n    addToList: (props: OutputRowProps) => void;\r\n    evalFunction: (test: string) => boolean; \r\n}\r\nclass GUI extends React.Component<GUIProps, GUIState> {\r\n    constructor(props: any) {\r\n        super(props);\r\n        this.state = {\r\n            pattStr: \"\",\r\n            testStr: \"\",\r\n            addToList: (props: OutputRowProps) => 0,\r\n            success: false,\r\n            evalFunction: (test: string) => false,\r\n        };\r\n\r\n        this.on_patt_change = this.on_patt_change.bind(this);\r\n        this.on_test_change = this.on_test_change.bind(this);\r\n    }\r\n    on_patt_change(pattStr: string) {\r\n        this.setState({pattStr})\r\n        const evalFunction = convertRegexToNFAFunction(pattStr);\r\n        this.setState({evalFunction}, this.updateSuccessValue);\r\n\r\n    }\r\n\r\n    on_test_change(testStr: string) {\r\n        this.setState({testStr}, this.updateSuccessValue);\r\n\r\n    }\r\n    \r\n    updateSuccessValue() {\r\n        this.setState({success: this.state.evalFunction(this.state.testStr)})\r\n    }\r\n    onKeyDown(e: any) {\r\n        if (e.keyCode === 13)\r\n            {\r\n            // prevent default behavior\r\n            e.preventDefault();\r\n            console.log(this.state.evalFunction);\r\n            const { pattStr, testStr, success } = this.state;\r\n            this.state.addToList({\r\n                pattStr, testStr, success\r\n            })\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <div id=\"holder_outer\" onKeyDown={(e) => this.onKeyDown(e)}>\r\n            <Intro />\r\n            <div className=\"holder\">\r\n                <FancyTextarea placeholder=\"Enter regex here...\" onchange={(e) => this.on_patt_change(e)} />\r\n                <FancyTextarea placeholder=\"Enter test string here...\" onchange={(e) => this.on_test_change(e)} />\r\n            </div>\r\n            <div className=\"holder\">\r\n                \r\n                    <Display success={this.state.success}pattStr={this.state.pattStr} testStr={this.state.testStr} \r\n                    setAddToList={(addToList: (props: OutputRowProps) => void) => {\r\n                        this.setState({addToList});\r\n                    }}\r\n                    />\r\n    \r\n            </div>\r\n        </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GUI;\r\n","import GUI from './GUIComp';\n\nfunction App() {\n  return (\n    <div className=\"App\">        \n        <GUI />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n\n"],"sourceRoot":""}